
logger = { -- Placeholder logger, for when DebugPlus isn't available
    log:   print
    debug: print
    info:  print
    warn:  print
    error: print
}

-- Internal stuff

concat_lists = (list_of_lists) ->
    output = {}
    for _, list in ipairs(list_of_lists)
        for _, item in ipairs(list)
            output[] = item
    return output

run_ordered_events = (funcs, previous_result=nil) ->
    if #funcs == 0
        return
    first_func = funcs[1]
    remaining_funcs = [func for func in *funcs[2,]]
    
    if type(first_func) == "table"
        -- print("Unpacking #{first_func}")
        funcs = concat_lists({
            first_func,
            remaining_funcs
        })
        first_func = funcs[1]
        remaining_funcs = [func for func in *funcs[2,]]

    G.E_MANAGER\add_event(Event({
        no_delete: true
        func: ->
            -- logger.debug("Running event #{_}, #{func} (#{previous_result})")
            result = first_func(previous_result)
            -- logger.debug("\tResult was #{result}")
            run_ordered_events(remaining_funcs, result)
            true  -- So that the event succeeds
    }))

n_tabs = (indentation) ->
    string.rep("\t", indentation)

-- Meat and potatoes

export class Test
    new: (name, funcs, prep=->) =>
        @name = name
        @funcs = funcs  -- Can be a single function or an array of them
    
    gather_events: (indentation=0) =>
        output = nil
        print(type(@funcs))
        if type(@funcs) == "function"
            print("#{@name}: singlet")
            output = {@funcs}
        else
            print("#{@name}: plural")
            output = @funcs
        output[] = (result) -> 
                if result == false
                    logger.warn(n_tabs(indentation) .. "\tTest \"#{@name}\" failed! :(")
                else
                    logger.info(n_tabs(indentation) .. "\tTest \"#{@name}\" passed! :)")
                result
        return output


export class TestBundle
    new: (name, tests) =>
        @name = name
        @tests = tests
    
    run: =>
        run_ordered_events(self\gather_events())

    gather_events: (indentation=0) =>
        output = {}
        tally = {passed: 0, failed: 0}
        output[] = ->
            logger.info(n_tabs(indentation) .. "Running test bundle \"#{@name}\" (contains #{#@tests} subtest(s))...")

        for _, test in ipairs(@tests)
            -- print("Gathering events for #{test.name}")
            events = test\gather_events(indentation+1)
            for _, event in ipairs(events)
                output[] = event
            output[] = (result) -> tally[result and "passed" or "failed"] += 1

        output[] = ->
            all_passed = tally.failed == 0
            via = all_passed and logger.info or logger.error
            via(n_tabs(indentation) .. "...done. Ran #{#@tests} test(s). #{tally.passed} passed, #{tally.failed} failed.")
            return all_passed
        
        print("output of", @name, output)
        output


export run_all_tests =  ->
    -- run_ordered_events(G.steamodded_tests.tests[1]\gather_events!)
    -- print()
    -- print()
    -- print()
    G.steamodded_tests\run!
        
init = () ->
    G.steamodded_tests = TestBundle("All tests", {}) if G.steamodded_tests == nil
init()

-- For actually making useful tests
export waiting_steps = (how_many=1) ->
    output = []
    for _=1,how_many
        output[] = -> nil
    output


export create_state_steps = (kwargs) ->
    {
        -> G.FUNCS.start_run(nil, {
            stake: 1
        }),
        waiting_steps(5)
        -> new_round(),
    }

-- DebugPlus stuff

success, dpAPI = pcall(require, "debugplus-api")
if success and dpAPI.isVersionCompatible(1)
    local debugplus = dpAPI.registerID("steamodded_test")
    logger = debugplus.logger

    debugplus.addCommand({
        name: "test",
        shortDesc: "Runs all tests.",
        desc: "IDK man!!! It runs your tests and tells you the results!!",
        exec: (args, rawArgs, dp) ->
            run_all_tests()
            "here we go :)"
})