
logger = { -- Placeholder logger, for when DebugPlus isn't available
    log:   print
    debug: print
    info:  print
    warn:  print
    error: print
}

-- Internal stuff

run_ordered_events = (funcs, previous_result=nil) ->
    if #funcs == 0
        return
    first_func = funcs[1]
    remaining_funcs = [func for func in *funcs[2,]]
    G.E_MANAGER\add_event(Event({
        no_delete: true
        func: ->
            -- logger.debug("Running event #{_}, #{func} (#{previous_result})")
            result = first_func(previous_result)
            -- logger.debug("\tResult was #{result}")
            run_ordered_events(remaining_funcs, result)
            true  -- So that the event succeeds
    }))

n_tabs = (indentation) ->
    string.rep("\t", indentation)

-- Meat and potatoes

export class Test
    new: (name, func, prep=->) =>
        @name = name
        @func = func
        @prep = prep
    
    gather_events: (indentation=0) =>
        {
            -> 
                -- print("#{@name} prep")
                @prep(),
            (result) -> 
                -- print("#{@name} func")
                @func(result),
            (result) -> 
                if result == false
                    logger.warn(n_tabs(indentation) .. "\tTest \"#{@name}\" failed! :(")
                else
                    logger.info(n_tabs(indentation) .. "\tTest \"#{@name}\" passed! :)")
                result
        }


export class TestBundle
    new: (name, tests) =>
        @name = name
        @tests = tests
    
    run: =>
        run_ordered_events(self\gather_events())

    gather_events: (indentation=0) =>
        output = {}
        tally = {passed: 0, failed: 0}
        output[] = ->
            logger.info(n_tabs(indentation) .. "Running test bundle \"#{@name}\" (contains #{#@tests} subtest(s))...")

        for _, test in ipairs(@tests)
            -- print("Gathering events for #{test.name}")
            events = test\gather_events(indentation+1)
            for _, event in ipairs(events)
                output[] = event
            output[] = (result) -> tally[result and "passed" or "failed"] += 1

        output[] = ->
            all_passed = tally.failed == 0
            via = all_passed and logger.info or logger.error
            via(n_tabs(indentation) .. "...done. Ran #{#@tests} test(s). #{tally.passed} passed, #{tally.failed} failed.")
            return all_passed
        
        print("output of", @name, output)
        output


export run_all_tests =  ->
    -- run_ordered_events(G.steamodded_tests.tests[1]\gather_events!)
    -- print()
    -- print()
    -- print()
    G.steamodded_tests\run!
        
init = () ->
    G.steamodded_tests = TestBundle("All tests", {}) if G.steamodded_tests == nil
init()

-- For actually making useful tests


export create_state = (kwargs) ->
    G.FUNCS.start_run(nil, {
        stake: 1
    })
    new_round()

-- DebugPlus stuff

success, dpAPI = pcall(require, "debugplus-api")
if success and dpAPI.isVersionCompatible(1)
    local debugplus = dpAPI.registerID("steamodded_test")
    logger = debugplus.logger

    debugplus.addCommand({
        name: "test",
        shortDesc: "Runs all tests.",
        desc: "IDK man!!! It runs your tests and tells you the results!!",
        exec: (args, rawArgs, dp) ->
            run_all_tests()
            "ok done ig"
})