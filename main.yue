
local logger = { -- Placeholder logger, for when DebugPlus isn't available
    log:   print
    debug: print
    info:  print
    warn:  print
    error: print
}

-- Internal stuff

run_ordered_events = (funcs) ->
    local result = nil
    for _, func in ipairs(funcs)
        G.E_MANAGER\add_event(Event({
            func: ->
                -- print("Running event #{_}, #{func} (#{result})")
                result = func(result)
                -- print("\tResult was #{result}")
                true  -- So that the event succeeds
        }))

n_tabs = (indentation) ->
    string.rep("\t", indentation)

-- Meat and potatoes

export class Test
    new: (name, func, prep=->) =>
        @name = name
        @func = func
        @prep = prep
    
    gather_events: (indentation=0) =>
        {
            -> 
                -- print("#{@name} prep")
                @prep(),
            (result) -> 
                -- print("#{@name} func")
                @func(result),
            (result) -> 
                if result == false
                    logger.warn(n_tabs(indentation) .. "\tTest \"#{@name}\" failed! :(")
                else
                    logger.info(n_tabs(indentation) .. "\tTest \"#{@name}\" passed! :)")
                result
        }


export class TestBundle
    new: (name, tests) =>
        @name = name
        @tests = tests
    
    run: =>
        run_ordered_events(self\gather_events())

    gather_events: (indentation=0) =>
        output = {}
        tally = {passed: 0, failed: 0}
        local total_subprocesses
        output[] = ->
            logger.info(n_tabs(indentation) .. "Running test bundle \"#{@name}\" (contains #{total_subprocesses} subtests)...")

        for _, test in ipairs(@tests)
            -- print("Gathering events for #{test.name}")
            events = test\gather_events(indentation+1)
            for _, event in ipairs(events)
                output[] = event
            output[] = (result) -> tally[result and "passed" or "failed"] += 1
        
        output[] = ->
            all_passed = tally.failed == 0
            via = all_passed and logger.info or logger.error
            via(n_tabs(indentation) .. "...done. Ran #{#@tests} test(s). #{tally.passed} passed, #{tally.failed} failed.")
            return all_passed
        
        total_subprocesses = #output - 2
        -- print("output of", @name, output)
        output


export run_all_tests =  ->
    -- run_ordered_events(G.steamodded_tests.tests[1]\gather_events!)
    -- print()
    -- print()
    -- print()
    G.steamodded_tests\run!
        
init = () ->
    G.steamodded_tests = TestBundle("All tests", {}) if G.steamodded_tests == nil
init()

-- For actually making useful tests


export create_state = (kwargs) ->
    G.FUNCS.start_run(nil, {
        stake: 1
    })
    new_round()

-- DebugPlus stuff

success, dpAPI = pcall(require, "debugplus-api")
if success and dpAPI.isVersionCompatible(1)
    local debugplus = dpAPI.registerID("steamodded_test")
    logger = debugplus.logger

    debugplus.addCommand({
        name: "test",
        shortDesc: "Runs all tests.",
        desc: "IDK man!!! It runs your tests and tells you the results!!",
        exec: (args, rawArgs, dp) ->
            run_all_tests()
            "ok done ig"
})